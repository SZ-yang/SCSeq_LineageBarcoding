GEMLI_items[['gene_expression']][9:14,1:5]
GEMLI_items[['barcodes']][1:5]
GEMLI_items = predict_lineages(GEMLI_items)
GEMLI_items[['prediction']][1:5,15:19]
GEMLI_items = test_lineages(GEMLI_items)
GEMLI_items$testing_results
# from https://github.com/UPSUTER/GEMLI
rm(list=ls())
# library(devtools); devtools::install_github("UPSUTER/GEMLI", subdir="GEMLI_package_v0")
library(GEMLI)
out_folder <- "/Users/kevinlin/Library/CloudStorage/Dropbox/Collaboration-and-People/Joshua/out/kevin/Writeup5/"
load(paste0(out_folder, 'GEMLI_example_data_matrix.RData'))
load(paste0(out_folder, 'GEMLI_example_barcode_information.RData'))
GEMLI_items = list()
GEMLI_items[['gene_expression']] = data_matrix
GEMLI_items[['barcodes']] = lineage_dict_bc
dim(data_matrix)
dim(lineage_dict_bc)
head(lineage_dict_bc)
table(lineage_dict_bc)
GEMLI_items = list()
GEMLI_items[['gene_expression']] = data_matrix
GEMLI_items[['barcodes']] = lineage_dict_bc
GEMLI_items[['gene_expression']][9:14,1:5]
GEMLI_items[['barcodes']][1:5]
GEMLI_items = GEMLI::predict_lineages(GEMLI_items)
GEMLI_items[['prediction']][1:5,15:19]
GEMLI_items = GEMLI::test_lineages(GEMLI_items)
GEMLI_items$testing_results
GEMLI_items = GEMLI::test_lineages(GEMLI_items, plot_results=T)
names(GEMLI::)
names(GEMLI_items)
GEMLI::visualize_as_network(GEMLI_items, cutoff=90) # top image
library(igraph)
GEMLI::visualize_as_network(GEMLI_items, cutoff=90) # top image
GEMLI::visualize_as_network(GEMLI_items, cutoff=50) # lower image
GEMLI::visualize_as_network(GEMLI_items, cutoff=90, ground_truth=T, highlight_FPs=T) # top image
GEMLI::visualize_as_network(GEMLI_items, cutoff=50, ground_truth=T, highlight_FPs=T) # lower image
GEMLI_items = GEMLI::prediction_to_lineage_information(GEMLI_items, cutoff=50)
GEMLI_items$predicted_lineage_table[1:5,]
GEMLI_items$predicted_lineages[1:5]
dim(GEMLI_items$predicted_lineage_table)
table(GEMLI_items$predicted_lineages)
length(unique(lineage_dict_bc))
head(GEMLI_items$predicted_lineage_table)
unique(GEMLI_items$predicted_lineage_table[,"clone.ID"])
GEMLI::suggest_network_trimming_to_size(GEMLI_items, max_size=2, cutoff=50) # left image
GEMLI_items_post_processed = GEMLI::trim_network_to_size(GEMLI_items, max_size=2, cutoff=50)
GEMLI::visualize_as_network(GEMLI_items_post_processed, cutoff=50) # right image
load(paste0(out_folder, 'GEMLI_crypts_example_data_matrix.RData'))
load(paste0(out_folder, 'GEMLI_crypts_example_barcode_information.RData'))
GEMLI_items_crypts = list()
GEMLI_items_crypts[['prediction']] = Crypts
GEMLI_items_crypts[['barcodes']] = Crypts_bc_dict
GEMLI::visualize_as_network(GEMLI_items_crypts, cutoff=70, display_orphan=F, max_edge_width=1, ground_truth=T, include_labels=F, layout_style="fr") # first image
GEMLI::visualize_as_network(GEMLI_items_crypts, cutoff=70, display_orphan=F, max_edge_width=1, ground_truth=T, include_labels=F, layout_style="kk") # second image
GEMLI::visualize_as_network(GEMLI_items_crypts, cutoff=70, display_orphan=F, max_edge_width=1, ground_truth=T, include_labels=F, layout_style="grid") # third image
load(paste0(out_folder, 'GEMLI_crypts_example_cell_type_annotation.RData'))
GEMLI::GEMLI_items_crypts[['cell_type']] = Crypts_annotation
GEMLI_items_crypts[['cell_type']] = Crypts_annotation
GEMLI::visualize_as_network(GEMLI_items_crypts, cutoff=70, max_edge_width=5, display_orphan=F, include_labels=F, ground_truth=T, highlight_FPs=T, layout_style="kk", cell_type_colors=T)
cell.type <- unique(GEMLI_items_crypts[['cell_type']]$cell.type)
color <- c("#5386BD", "skyblue1", "darkgreen", "gold", "red", "darkred", "black")
Cell_type_color <- data.frame(cell.type, color)
GEMLI_items_crypts[['cell_type_color']] = Cell_type_color
GEMLI::visualize_as_network(GEMLI_items_crypts, cutoff=70, max_edge_width=5, display_orphan=F, include_labels=F, ground_truth=T, highlight_FPs=T, layout_style="kk", cell_type_colors=T)
GEMLI_items_crypts = GEMLI::prediction_to_lineage_information(GEMLI_items_crypts, cutoff=50)
GEMLI::cell_type_composition_plot(GEMLI_items_crypts, cell_type_colors=T, type=c("bubble"))
library(tidyverse)
GEMLI::cell_type_composition_plot(GEMLI_items_crypts, cell_type_colors=T, type=c("bubble"))
GEMLI::cell_type_composition_plot(GEMLI_items_crypts, ground_truth=F, cell_type_colors=T, type=c("upsetR"))
install.packages("upsetR")
install.packages("UpsetR")
install.packages("UpSetR")
library(UpSetR)
GEMLI::cell_type_composition_plot(GEMLI_items_crypts, ground_truth=F, cell_type_colors=T, type=c("upsetR"))
GEMLI::cell_type_composition_plot(GEMLI_items_crypts, ground_truth=F, cell_type_colors=T, type=c("plain"))
library(tidyverse)
GEMLI::cell_type_composition_plot(GEMLI_items_crypts, ground_truth=F, cell_type_colors=T, type=c("plain"))
Crypts_bc_dict
length(Crypts_bc_dict)
Crypts
dim(Crypts)
length(Crypts_bc_dict)
load(paste0(out_folder, 'GEMLI_cancer_example_norm_count.RData'))
load(paste0(out_folder, 'GEMLI_cancer_example_predicted_lineages.RData'))
load(paste0(out_folder, 'GEMLI_cancer_example_cell_type_annotation.RData'))
GEMLI_items = list()
GEMLI_items[['gene_expression']] = Cancer_norm_count
GEMLI_items[['predicted_lineage_table']] = Cancer_predicted_lineages
GEMLI_items[['cell_type']] = Cancer_annotation
GEMLI::cell_type_composition_plot(GEMLI_items, type=c("plain"))
GEMLI::cell_type_composition_plot(GEMLI_items, type=c("upsetR"))
GEMLI_items <- GEMLI::extract_cell_fate_lineages(GEMLI_items, selection=c("inv_tumor", "DCIS"), unique=FALSE, threshold=c(10,10))
GEMLI_items[['cell_fate_analysis']][1:10,]
table(GEMLI_items[['cell_fate_analysis']]$cell.fate)
GEMLI_items <- GEMLI::cell_fate_DEG_calling(GEMLI_items, ident1="sym_DCIS", ident2="asym_DCIS", min.pct=0.05, logfc.threshold=0.1)
library(Seurat)
GEMLI_items <- GEMLI::cell_fate_DEG_calling(GEMLI_items, ident1="sym_DCIS", ident2="asym_DCIS", min.pct=0.05, logfc.threshold=0.1)
library(Matrix)
GEMLI_items <- GEMLI::cell_fate_DEG_calling(GEMLI_items, ident1="sym_DCIS", ident2="asym_DCIS", min.pct=0.05, logfc.threshold=0.1)
dim(Cancer_norm_count)
Cancer_norm_count[1:5,1:5]
GEMLI_items[['gene_expression']] = Matrix::Matrix(Cancer_norm_count, sparse=TRUE)
GEMLI_items <- GEMLI::cell_fate_DEG_calling(GEMLI_items, ident1="sym_DCIS", ident2="asym_DCIS", min.pct=0.05, logfc.threshold=0.1)
GEMLI_items[['cell_fate_analysis']]$cell.fate
table(GEMLI_items[['cell_fate_analysis']]$cell.fate)
head(GEMLI_items[['cell_fate_analysis']])
Cancer_norm_count[1:5,1:5]
GEMLI_Seurat <- CreateSeuratObject(GEMLI_items[['gene_expression']], project = "SeuratProject", assay = "RNA")
GEMLI_Seurat
dim(Cancer_norm_count)
Metadata <- GEMLI_items[['cell_fate_analysis']]; Metadata$ident<-NA
Metadata$ident[Metadata$cell.fate %in% ident1]<-"ident1"
ident1="sym_DCIS"
ident2="asym_DCIS"
Metadata$ident[Metadata$cell.fate %in% ident1]<-"ident1"
Metadata$ident[Metadata$cell.fate %in% ident2]<-"ident2"
head(Metadata)
Metadata
Meta <- as.data.frame(Metadata[,c(5)])
rownames(Meta) <- Metadata$cell.ID; colnames(Meta)<-c("cell.fate")
head(Meta)
rownames(Meta) <- Metadata$cell.ID; colnames(Meta)<-c("cell.fate")
GEMLI_Seurat <- AddMetaData(GEMLI_Seurat, Meta, col.name = NULL)
DefaultAssay(object = GEMLI_Seurat) <- "RNA"
Idents(GEMLI_Seurat) <- GEMLI_Seurat$cell.fate
GEMLI_Seurat
head(GEMLI_Seurat@meta.data)
DEG <- FindMarkers(object = GEMLI_Seurat, ident.1 = "ident1", ident.2 = "ident2")
GEMLI_Seurat <- CreateSeuratObject(GEMLI_items[['gene_expression']], project = "SeuratProject", assay = "RNA")
Metadata <- GEMLI_items[['cell_fate_analysis']];
Metadata$ident <- "blank"
ident1="sym_DCIS"
ident2="asym_DCIS"
Metadata$ident[Metadata$cell.fate %in% ident1]<-"ident1"
Metadata$ident[Metadata$cell.fate %in% ident2]<-"ident2"
Meta <- as.data.frame(Metadata[,c(5)])
rownames(Meta) <- Metadata$cell.ID; colnames(Meta)<-c("cell.fate")
GEMLI_Seurat <- AddMetaData(GEMLI_Seurat, Meta, col.name = NULL)
DefaultAssay(object = GEMLI_Seurat) <- "RNA"
Idents(GEMLI_Seurat) <- GEMLI_Seurat$cell.fate
DEG <- FindMarkers(object = GEMLI_Seurat, ident.1 = "ident1", ident.2 = "ident2")
table(GEMLI_Seurat$cell.fate)
SeuratObject::LayerData(GEMLI_Seurat, assay = "RNA", layer = "counts")
library(Seurat)
library(SeuratData)
devtools::install_github('satijalab/seurat-data')
library(Seurat)
library(SeuratData)
library(ggplot2)
ifnb <- LoadData("ifnb")
ifnb <- SeuratData::LoadData("ifnb")
SeuratData::LoadData
?SeuratData::LoadData
SeuratData::AvailableData()
ifnb <- SeuratData::InstallData("ifnb")
SeuratData::InstallData("ifnb")
SeuratData::InstallData("cbmc")
cbmc <- SeuratData::LoadData("cbmc")
# Normalize the data
cbmc <- NormalizeData(cbmc)
cbmc
head(cbmc@meta.data)
table(cbmc$rna_annotations)
# Find DE features between CD16 Mono and CD1 Mono
Idents(cbmc) <- "rna_annotations"
# Find DE features between CD16 Mono and CD1 Mono
Idents(cbmc) <- "rna_annotations"
monocyte.de.markers <- FindMarkers(cbmc,
ident.1 = "Memory CD4 T",
ident.2 = "CD14+ Mono")
GEMLI_Seurat
SeuratObject::LayerData(GEMLI_Seurat,
layer = "data",
assay = "RNA") <- SeuratObject::LayerData(GEMLI_Seurat,
layer = "counts",
assay = "RNA")
DEG <- FindMarkers(object = GEMLI_Seurat,
ident.1 = "ident1",
ident.2 = "ident2",
min.pct=0.05,
logfc.threshold=0.1)
# check
mat <- SeuratObject::LayerData(seurat_obj,
layer = "counts",
assay = "RNA")
seurat_obj <- Seurat::RunUMAP(seurat_obj,
reduction = "LCL",
dims = 1:64)
?Seurat::DimPlot
?cutree
?stats::as.dist
rm(list=ls())
library(Seurat)
library(GEMLI)
out_folder <- "~/kzlinlab/projects/scContrastiveLearn/out/kevin/Writeup5/"
load(paste0(out_folder, "Larry_41093_2000_norm_log_cleaned.RData"))
?ggplot2::ggsave
12/20
12*0.08
900*672/714
exp(seq(log(1), log(2), length.out = 5))-1
100/6
rm(list=ls())
library(SeuratData)
# grab a simple dataset
AvailableData()
rm(list=ls())
library(Seurat)
library(SeuratData)
# grab a simple dataset
SeuratData::InstallData("stxKidney")
data("stxKidney")
ls()
rm(list=ls())
library(Seurat)
library(SeuratData)
# grab a simple dataset
SeuratData::InstallData("stxKidney")
data("stxKidney")
stxKidney
# grab a simple dataset
SeuratData::InstallData("cbmc") # (You only need to run this once ever -- this downloads the dataset)
data("cbmc")
cbmc
rm(list=ls())
library(Seurat)
library(SeuratObject)
library(SeuratData)
# grab a simple dataset
SeuratData::InstallData("cbmc") # (You only need to run this once ever -- this downloads the dataset)
data("cbmc")
cbmc
cbmc <- Seurat::UpdateSeuratObject(cmbc)
Seurat::UpdateSeuratObject(cmbc)
ls()
cmbc
rm(list=ls())
library(Seurat)
library(SeuratObject)
library(SeuratData)
# grab a simple dataset
SeuratData::InstallData("cbmc") # (You only need to run this once ever -- this downloads the dataset)
data("cbmc")
ls()
"cbmc"
force(cbmc)
View(cbmc)
Seurat::UpdateSeuratObject(cmbc)
Seurat::UpdateSeuratObject(cbmc)
rm(list=ls())
library(Seurat)
library(SeuratObject)
library(SeuratData)
# grab a simple dataset
SeuratData::InstallData("cbmc") # (You only need to run this once ever -- this downloads the dataset)
data("cbmc")
Seurat::UpdateSeuratObject(cbmc)
# this is your cound data
count_matrix <- SeuratObject::LayerData(
object = cbmc,
assay = "RNA",
layer = "counts"
)
cbmc <- Seurat::UpdateSeuratObject(cbmc) # (Usually you don't need this line. This is just to update the loaded data based on Seurat's latest format)
cbmc
# this is your cound data
count_matrix <- SeuratObject::LayerData(
object = cbmc,
assay = "RNA",
layer = "counts"
)
rm(list=ls())
library(Seurat)
library(SeuratObject)
library(SeuratData)
# grab a simple dataset
SeuratData::InstallData("cbmc") # (You only need to run this once ever -- this downloads the dataset)
data("cbmc")
cbmc <- Seurat::UpdateSeuratObject(cbmc) # (Usually you don't need this line. This is just to update the loaded data based on Seurat's latest format)
# this is your Seurat object (8617 cells, 20501 features)
cbmc
# do a simple highly-variable gene selection
cbmc <- Seurat::FindVariableFeatures(cbmc,
selection.method = "vst",
nfeatures = 2000)
# this is your count data
count_matrix <- SeuratObject::LayerData(
object = cbmc,
assay = "RNA",
layer = "counts"
)
cbmc
# this is your count data
count_matrix <- SeuratObject::LayerData(
object = cbmc,
assay = "RNA",
layer = "counts",
features = Seurat::VariableFeatures(cbmc)
)
count_matrix[1:5,1:5]
head(rownames(count_matrix), 50)
head(colnames(count_matrix), 50) # these are some of the gene names
class(count_matrix)
count_matrix_dense <- as.matrix(count_matrix)
# convert into a matrix
# let's grab a simple sub-matrix for ease of computation
count_matrix_dense <- as.matrix(count_matrix)[1:100,1:20]
count_matrix_dense <- t(count_matrix_dense) # We need it to be cells-by-genes for the following function
dim(count_matrix_dense)
# convert into a matrix
# let's grab a simple sub-matrix for ease of computation
count_matrix_dense <- as.matrix(count_matrix)[1:100,1:20]
count_matrix_dense[1:5,1:5]
# convert into a matrix
# let's grab a simple sub-matrix for ease of computation
count_matrix_dense <- as.matrix(count_matrix)[1:20,1:100]
count_matrix_dense <- t(count_matrix_dense) # We need it to be cells-by-genes for the following function
pca_res <- stats::prcomp(count_matrix_dense,
center = FALSE,
scale. = FALSE)
# the "x" is the denoised matrix
dim(pca_res$x)
pca_res$x[1:5,1:5]
# the "rotation" is the PCA components
dim(pca_res$rotation)
names(pca_res)
pca_res$sdev
# to compute the low-dimensional components, you do a simple multiplication
pca_components <- count_matrix_dense %*% pca_res$rotation
# to compute the low-dimensional components, you do a simple multiplication
pca_components <- count_matrix_dense %*% pca_res$rotation
dim(pca_components)
pca_components[1:5,1:5]
dim(eigen_genes)
# the "rotation" is the eigen-genes
eigen_genes <- pca_res$rotation
dim(eigen_genes)
eigen_genes[1:5,1:5]
?stats::prcomp
?stats::princomp
?stats::prcomp
# the "x" is the denoised matrix
pca_denoised <- pca_res$x
dim(pca_denoised)
pca_denoised[1:5,1:5]
eigen_genes
# the "rotation" is the eigen-genes
eigen_genes <- pca_res$rotation
dim(eigen_genes)
eigen_genes[1:5,1:5]
# how are these two related?
pca_components2 <- count_matrix_dense %*% eigen_genes[,1:2]
dim(pca_components2)
pca_components2[1:5,1:5]
pca_components2[1:5,]
sum(abs(pca_components2 - pca_components[,1:2]))
# to compute the denoised (low-dimensional), you do a simple multiplication
# in fact, pca_res$rotation is a {Unitary matrix} that represents the eigen-bases
# that means we can actually recover pca_denoised using eigen_genes
pca_denoised <- count_matrix_dense %*% eigen_genes[,1:2] %*% t(eigen_genes[,1:2])
pca_denoised[1:5,1:5]
Matrix::rankMatrix(pca_denoised)
Matrix::rankMatrix(count_matrix_dense)
rm(list=ls())
library(Seurat)
library(SeuratObject)
library(SeuratData)
# grab a simple dataset
SeuratData::InstallData("cbmc") # (You only need to run this once ever -- this downloads the dataset)
data("cbmc")
cbmc <- Seurat::UpdateSeuratObject(cbmc) # (Usually you don't need this line. This is just to update the loaded data based on Seurat's latest format)
# this is your Seurat object (8617 cells, 20501 features)
cbmc
# do a simple highly-variable gene selection
cbmc <- Seurat::FindVariableFeatures(cbmc,
selection.method = "vst",
nfeatures = 2000)
cbmc
# this is your count data
count_matrix <- SeuratObject::LayerData(
object = cbmc,
assay = "RNA",
layer = "counts",
features = Seurat::VariableFeatures(cbmc)
)
dim(count_matrix)
head(rownames(count_matrix), 50) # these are some of the gene names
head(colnames(count_matrix), 50) # these are some of the cell barcodes
count_matrix[1:5,1:5]
class(count_matrix) # notice it's a sparse matrix
# convert into a matrix
# let's grab a simple sub-matrix for ease of computation
count_matrix_dense <- as.matrix(count_matrix)[1:20,1:100]
count_matrix_dense <- t(count_matrix_dense) # We need it to be cells-by-genes for the following function
# we'll turn off center and scale just to make my demo clear
pca_res <- stats::princomp(count_matrix_dense,
center = FALSE,
scale. = FALSE)
# the "x" is the PCA components (i.e., cell-by-PC)
pca_components <- pca_res$x
dim(pca_components)
pca_components[1:5,1:5]
# if we wanted only the first 2 PC's, we would only keep the first 2 columns of pca_components
# the "rotation" is the eigen-genes
eigen_genes <- pca_res$rotation
dim(eigen_genes)
eigen_genes[1:5,1:5]
# how are these two related?
pca_components2 <- count_matrix_dense %*% eigen_genes[,1:2]
rm(list=ls())
library(Seurat)
library(SeuratObject)
library(SeuratData)
# grab a simple dataset
SeuratData::InstallData("cbmc") # (You only need to run this once ever -- this downloads the dataset)
data("cbmc")
cbmc <- Seurat::UpdateSeuratObject(cbmc) # (Usually you don't need this line. This is just to update the loaded data based on Seurat's latest format)
# this is your Seurat object (8617 cells, 20501 features)
cbmc
# do a simple highly-variable gene selection
cbmc <- Seurat::FindVariableFeatures(cbmc,
selection.method = "vst",
nfeatures = 2000)
cbmc
# this is your count data
count_matrix <- SeuratObject::LayerData(
object = cbmc,
assay = "RNA",
layer = "counts",
features = Seurat::VariableFeatures(cbmc)
)
dim(count_matrix)
head(rownames(count_matrix), 50) # these are some of the gene names
head(colnames(count_matrix), 50) # these are some of the cell barcodes
count_matrix[1:5,1:5]
class(count_matrix) # notice it's a sparse matrix
# convert into a matrix
# let's grab a simple sub-matrix for ease of computation
count_matrix_dense <- as.matrix(count_matrix)[1:20,1:100]
count_matrix_dense <- t(count_matrix_dense) # We need it to be cells-by-genes for the following function
# we'll turn off center and scale just to make my demo clear
pca_res <- stats::prcomp(count_matrix_dense,
center = FALSE,
scale. = FALSE)
# the "x" is the PCA components (i.e., cell-by-PC)
pca_components <- pca_res$x
dim(pca_components)
pca_components[1:5,1:5]
# if we wanted only the first 2 PC's, we would only keep the first 2 columns of pca_components
# the "rotation" is the eigen-genes
eigen_genes <- pca_res$rotation
dim(eigen_genes)
eigen_genes[1:5,1:5]
# how are these two related?
pca_components2 <- count_matrix_dense %*% eigen_genes[,1:2]
dim(pca_components2)
pca_components2[1:5,]
sum(abs(pca_components2 - pca_components[,1:2])) # it matches!
# to compute the denoised (low-dimensional), you do a simple multiplication
# in fact, pca_res$rotation is a {Unitary matrix} that represents the eigen-bases
# that means we can actually recover pca_denoised using eigen_genes
pca_denoised <- count_matrix_dense %*% eigen_genes[,1:2] %*% t(eigen_genes[,1:2])
dim(pca_denoised)
pca_denoised[1:5,1:5]
# notice this is "cell by genes" again
Matrix::rankMatrix(pca_denoised) # This matrix has rank 2. This means that this matrix (which as 20 genes still) is has a 2-dimensional structure
Matrix::rankMatrix(count_matrix_dense) # this original matrix had the full rank of 20
rm(list=ls())
library(Seurat)
rm(list=ls())
library(Seurat)
load("/Users/kevinlin/Downloads/all_data_final_lineages.RData")
ls()
all_data
head(all_data@meta.data)
Seurat::DimPlot(all_data, group.by = "OG_condition")
keep_vec <- rep(FALSE, length(Seurat::Cells(all_data)))
keep_vec[grep("^Lin*", all_data$Lineage)] <- TRUE
table(keep_vec)
all_data$keep <- keep_vec
all_data <- subset(all_data, keep == TRUE)
Seurat::DimPlot(all_data, group.by = "OG_condition")
hist(table(all_data$Lineage))
tab_vec <- table(all_data$Lineage)
quantile(tab_vec)
tab_vec <- log10(tab_vec)
quantile(tab_vec)
tab_vec <- table(all_data$Lineage)
length(which(tab_vec >= 5))
tab_vec <- table(all_data$Lineage)
lineage_names <- names(tab_vec)[tab_vec >= 5]
keep_vec <- rep(FALSE, length(Seurat::Cells(all_data)))
keep_vec[all_data$Lineage %in% lineage_names] <- TRUE
table(keep_vec)
sort(tab_vec ,decreasing = TRUE)
sort(tab_vec ,decreasing = TRUE)[1:10]
tab_vec <- table(all_data$Lineage)
lineage_names <- names(tab_vec)[tab_vec >= 5]
lineage_names <- setdiff(lineage_names, "Lin221115")
keep_vec <- rep(FALSE, length(Seurat::Cells(all_data)))
keep_vec[all_data$Lineage %in% lineage_names] <- TRUE
table(keep_vec)
all_data$keep <- keep_vec
all_data <- subset(all_data, keep == TRUE)
Seurat::DimPlot(all_data, group.by = "OG_condition")
all_data
tab_vec <- table(all_data$Lineage)
mean(tab_vec)
length(tab_vec)
?ggplot2::position_jitter
